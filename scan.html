<!DOCTYPE html>
<html>

<head>
    <title>Werewolf</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/purecss@3.0.0/build/pure-min.css"
        integrity="sha384-X38yfunGUhNzHpBaEBsWLO+A0HDYOQi8ufWDkZ0k9e0eXz/tH3II7uKZ9msv++Ls" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="scripts.js"></script>
</head>

<body x-data="setup()" @click="showMenu = false">

    <div class="pure-g">

        <!-- Hamburger menu: for mobile devices. When the button is clicked the nav menu options are displayed -->
        <div class="pure-u-1 nav-menu" x-show="!isGameStarted">
            <button @click.stop="showMenu = !showMenu" class="hamburger-button">
                <i class="fa-solid fa-bars"></i>
            </button>
            <div id="hamburger-menu" class="pure-menu">
                <ul class="pure-menu-list" x-show="showMenu" x-transition.duration.500ms.scale.0.origin.top>
                    <li class="pure-menu-item">
                        <a href="index.html" class="pure-menu-link">
                            <span><i class="fa-solid fa-house"></i></span>
                            Home
                        </a>
                    </li>
                    <li class="pure-menu-item" x-show="players.length > 0 && !isGameStarted && !isScanStarted">
                        <a href="setup.html" class="pure-menu-link">
                            <span><i class="fa-solid fa-tents"></i></span>
                            Back to current lobby
                        </a>
                    </li>
                    <li class="pure-menu-item" x-show="isGameStarted">
                        <a href="gameplay.html" class="pure-menu-link">
                            <span><i class="fa-solid fa-play"></i></span>
                            Back to in-progress game
                        </a>
                    </li>
                    <li class="pure-menu-item" x-show="isScanStarted">
                        <a href="next_player_to_scan.html" class="pure-menu-link">
                            <span><i class="fa-solid fa-users-viewfinder"></i></span>
                            Back to role setup
                        </a>
                    </li>
                    <li class="pure-menu-item">
                        <a href="about.html" class="pure-menu-link">
                            <span><i class="fa-solid fa-circle-info"></i></span>
                            About this app
                        </a>
                    </li>
                    <li class="pure-menu-item">
                        <a href="index.html" class="pure-menu-link" @click="resetGame()">
                            <span><i class="fa-solid fa-bomb"></i></span>
                            Reset game and app
                        </a>
                    </li>
                </ul>
            </div>
        </div>

        <div class="panel pure-u-1">
            <h1>Scan player cards</h1>
            <p x-text="gameInfo">Scan the player cards to assign roles.</p>
        </div>

        <div class="panel pure-u-1" x-show="showStartGameButton">
            <h4>Are all players & devices ready?</h4>
            <button class="pure-button button-primary" @click="startTheGame()">
                <i class="fa-solid fa-circle-play"></i>
                Start game
            </button>
        </div>
    </div>

    <div id="sniffScreen" x-show="showSniffScreen">
        <div style="text-align:center;">
            <p x-text="snifferInstructions" class="input-help" x-show="displaySnifferInstructions"
                x-transition:leave.opacity.0.duration.4000ms.delay.2000ms></p>
            <p x-text="sniffInstructions"></p>
            <p class="sniffBackResult" x-text="sniffBackResult" x-show="sniffBackResult"></p>
        </div>
        <button id="exit-sniff" class="pure-button button-secondary" @click="exitSniff()">
            <i class="fa-solid fa-times"></i>
            Exit
        </button>
    </div>

    <div id="specialAbility" class="special-ability" x-show="specialAbilityVisible">
        <!-- Secondary controls -->
        <div id="role-secondary-controls">
            <!-- Sniff control -->
            <button class="pure-button button-secondary" x-show="isHoundskeeper" @click="initiateSniff()">
                <i class="fa-solid fa-nose"></i>
                Sniff
            </button>
            <!-- Role help control -->
            <button class="pure-button button-secondary" @click="showRoleHelp = !showRoleHelp"
                :class="{ 'active': showRoleHelp }">
                <i class="fa-solid fa-question"></i>
                Help
            </button>
            <!-- Role help description -->
            <div id="role-help" x-show="showRoleHelp">
                <p x-text="roleHelp[role]"></p>
                <p x-show="isHoundskeeper" class="houndskeeper-help">
                    <i class="fa-solid fa-triangle-exclamation"></i>
                    Houndskeeper & Werewolf players may sniff out the role of adjacent players. Other players may bluff
                    a sniff.
                </p>
            </div>
        </div>

        <p id="abilityMessage" x-text="abilityMessage"></p>
        <!-- Gossip messages -->
        <p id="gossip1" x-text="gossip1" x-show="gossip1"></p>
        <p id="gossip2" x-text="gossip2" x-show="gossip2"></p>
        <div id="ability-effect"></div>
        <!-- The main ability button -->
        <!-- Removed this: :disabled="getCurrentPlayer().usedAbility" -->
        <button id="useAbilityButton" x-show="showMainAbilityButton" class="pure-button" @click="activateRole()"
            x-transition.opacity.scale.30.duration.1500ms :disabled="getCurrentPlayer().usedAbility">
            <i class="fa-solid fa-hands-holding-circle"></i>
        </button>
        <!-- Villager controls -->
        <div id="villagerControls" x-show="showVillagerControls" x-transition.opacity.0.duration.1500ms>
            <select class="playerSelect" x-model="selectedPlayer" @change="villagerAbility()">
                <option value="">Select a player</option>
                <template x-for="player in playersToVote" :key="player.name">
                    <option x-text="player.name" :value="player.id"></option>
                </template>
            </select>
            <br>
        </div>
        <!-- Tracker controls -->
        <button id="trackLeftButton" x-show="showTrackerButtons" class="trackerButton pure-button button-primary"
            @click="trackerAbility(trackDirection='left')">
            <i class="fa-solid fa-arrow-left"></i>
            Track left
        </button>
        <button id="trackRightButton" x-show="showTrackerButtons" class="trackerButton pure-button button-primary"
            @click="trackerAbility(trackDirection='right')">
            Track right
            <i class="fa-solid fa-arrow-right"></i>
        </button>
        <!-- Watcher controls -->
        <div id="watcherControls" x-show="showWatcherControls" x-transition.opacity.0.duration.1500ms>
            <select class="playerSelect" x-model="selectedPlayer" @change="watcherAbility()">
                <option value="">Select a player</option>
                <template x-for="player in playersToView" :key="player.name">
                    <option x-text="player.name" :value="player.name"></option>
                </template>
            </select>
            <br>
        </div>
        <!-- Button which navigates the user back to the gameplay.html page -->
        <button id="cancel-ability" @click="exit()" class="pure-button button-primary">
            <i class="fa-solid fa-arrow-left"></i>
            Go back
        </button>
    </div>

    <script>
        function setup() {
            return {
                showMenu: false,
                roles: ["werewolf", "villager", "watcher", "tracker", "deviant", "saint", "gossip", "turncloak", "astrologer", "drifter", "houndskeeper"],
                roleHelp: {
                    "werewolf": "You are a Werewolf. Survive and ensure a member of the townfolk dies. You can also win if all Werewolves vote for the Saint.",
                    "villager": "You are a Villager. Help the town eliminate a Werewolf. Villagers may agree to appoint a ringleader, giving that player an extra vote at the end.",
                    "watcher": "You are the Watcher. You can view another player to gain a clue about their role.",
                    "tracker": "You are the Tracker. You can choose which half of the players at the table to track; this will determine if a Werewolf is among them.",
                    "deviant": "You are the Deviant. Your only goal is to trick the town into killing you.",
                    "saint": "You are the Saint. Don't let the Werewolves discover your role. Discreetly guide the townsfolk to victory.",
                    "gossip": "You are the Gossip. You get 2 clues (the second is available halfway through the game). One clue may be false.",
                    "turncloak": "You are the Turncloak. You serve the Werewolves and must help them win â€” even if you must die.",
                    "astrologer": "You are the Astrologer. You can determine one role that is definitely in play.",
                    "drifter": "You are the Drifter. You can determine 2 roles not in play. In other words, you identify 2 of the non-player cards from the centre.",
                    "houndskeeper": "You are the Houndskeeper. You may sniff out the role of either player next to you...if they allow it. Use the 'Sniff' and pass the device to your target. Afterward, you can get your results using the round button below."
                },
                players: [],
                isClient: localStorage.getItem('isClient') === "true",
                isScanStarted: localStorage.getItem('isScanStarted') === "true",
                isGameStarted: localStorage.getItem('isGameStarted') === "true",
                extraRoles: [],
                playersToView: [],
                playersToVote: [],
                abilityMessage: '',
                gossip1: null,
                gossip2: null,
                holdTimeout: null,
                gameInfo: 'Scan the player cards to assign roles.',
                showStartGameButton: false,
                specialAbilityVisible: false,
                showMainAbilityButton: true,
                showWatcherControls: false,
                showVillagerControls: false,
                showTrackerButtons: false,
                isHoundskeeper: false,
                showRoleHelp: false,
                showSniffScreen: false,
                sniffResult: '',
                sniffBackResult: '',
                snifferInstructions: '',
                displaySnifferInstructions: true,
                sniffInstructions: 'Pass the device to the player on your left or right for scanning.',
                audio: new Audio('sounds/power_activated.mp3'),
                role: null,
                id: null,
                selectedPlayer: null,

                getRoleWithId(id) {
                    // Given the non-readable code, return the matching role.
                    roles = {
                        "0OO0O00000OOO0OOOOO0OO00OOO0O0": "villager",
                        "0OO0O0O0O000O0O0O0O0O0O0O0O0O0": "villager",
                        "0OO0OOO0O0O0O0O0O0O0O0O0O000O0": "villager",
                        "0OO0O0O0OOOO0OOOOO00O000OOO0O0": "werewolf",
                        "0OO00O0OO0O00O0O0000O00O00O0O0": "werewolf",
                        "0OO0O0O0O0O0O0O0O0O0O0O0O0O0O0": "werewolf",
                        "0OO0OO000OO0O0O0O0000OO00O0OO0": "watcher",
                        "0OO0O0O0OOO000OO0O00O0O0O0O0O0": "tracker",
                        "0OO0O00O0O0O0O0O0O0O0O00O0O0O0": "deviant",
                        "0OO0O00O0O0O0O0O0OO0OO0O0O0O00": "saint",
                        "0OO0O0O0O0O00O0O0O0O0O00O0O0O0": "gossip",
                        "0OO00O00O000O0O0O0O0O0O0O0O0O0": "turncloak",
                        "0OO0O0O0O0O0O0O0O000O0O0O0O0O0": "astrologer",
                        "0OO0O000O0O0O0O0O0O0O0O0OOO0O0": "drifter",
                        "0OO0O00OO0O0O0O0O000O0O0O0O0O0": "houndskeeper"
                    }
                    return roles[id];
                },

                getRole() {
                    const params = new URLSearchParams(window.location.search);
                    const id = params.get('id');
                    const role = this.getRoleWithId(params.get('id'));

                    // The role must exist in the roles array
                    if (this.roles.includes(role)) {
                        this.role = role;
                        this.id = id;
                    }
                    return role;
                },

                getCurrentPlayer() {
                    // Using the id parameter, get the current player  
                    const params = new URLSearchParams(window.location.search);
                    const id = params.get('id');

                    return this.players.find(player => player.id === id);
                },

                loadPlayersFromLocalStorage() {
                    let storedPlayers = JSON.parse(localStorage.getItem('players'));
                    if (storedPlayers) {
                        this.players = storedPlayers;
                    }
                },

                loadExtraRolesFromLocalStorage() {
                    const storedExtraRoles = JSON.parse(localStorage.getItem('extraRoles'));
                    if (storedExtraRoles) {
                        this.extraRoles = storedExtraRoles;
                    }
                },

                initiateSniff() {
                    // When the player clicks the sniff button, a screen appears
                    this.showSniffScreen = true;

                    // Update the player list to indicate that this player is trying to sniff
                    let currentPlayer = this.getCurrentPlayer();
                    const leftPlayer = this.getAdjacentPlayer("left");
                    const rightPlayer = this.getAdjacentPlayer("right");

                    this.snifferInstructions = `(Pass the device to either ${leftPlayer.name} or ${rightPlayer.name})`;
                    this.displaySnifferInstructions = false;
                    this.sniffInstructions = `Let ${currentPlayer.name} sniff you?`;
                    currentPlayer.isSniffing = true;
                    this.savePlayersToLocalStorage();
                },

                receiveSniff(sniffingPlayer) {
                    // When the player receives the device, they can allow the player to sniff them

                    function addSniffResultToPlayer(player, sniffClue) {
                        // Add the sniff result to the player's sniff results
                        if (player.sniffResults) {
                            // Add the sniff clue as long as it's not already in the list
                            if (!player.sniffResults.includes(sniffClue))
                                player.sniffResults.push(sniffClue);
                        }
                        else {
                            player.sniffResults = [sniffClue];
                        }
                    }

                    let currentPlayer = this.getCurrentPlayer();
                    const sniffResult = `${currentPlayer.name} is ${useAorAn(currentPlayer.role)} ${currentPlayer.role}`;

                    // Ensure the player giving the sniff is a Werewolf or Houndskeeper before giving the clue
                    if (sniffingPlayer.role === 'werewolf' || sniffingPlayer.role === 'houndskeeper') {
                        addSniffResultToPlayer(sniffingPlayer, sniffResult);
                    }

                    // If this player is a Werewolf or Houndskeeper, they can sniff back! Show them the sniffer's role.
                    if (currentPlayer.role === 'werewolf' || currentPlayer.role === 'houndskeeper') {
                        this.sniffBackResult = `${sniffingPlayer.name} is ${useAorAn(sniffingPlayer.role)} ${sniffingPlayer.role}`;
                        addSniffResultToPlayer(currentPlayer, this.sniffBackResult);
                    }

                    // Mark the player as no longer sniffing
                    sniffingPlayer.isSniffing = false;

                    localStorage.setItem('players', JSON.stringify(this.players));

                    this.sniffInstructions = `${sniffingPlayer.name} attempted to sniff you! `;
                    this.sniffInstructions += "Exit and return the device.";

                },

                exitSniff() {
                    // When the player exits the sniff, the screen disappears
                    this.showSniffScreen = false;

                    // Remove the sniffing flag from the player
                    let currentPlayer = this.getCurrentPlayer();
                    currentPlayer.isSniffing = false;
                    this.savePlayersToLocalStorage();

                    // Go back to the gameplay page
                    window.location.href = 'gameplay.html';
                },

                assignRole(role) {
                    // Get the next unassigned player and assign the role
                    for (let player of this.players) {
                        if (!player.role) {
                            player.role = role;
                            player.id = this.id;
                            break;
                        }
                    }
                    this.savePlayersToLocalStorage();
                },

                assignExtraRole() {
                    // Push the role to the extraRoles array and save it to local storage
                    this.extraRoles.push(this.getRole());
                    localStorage.setItem('extraRoles', JSON.stringify(this.extraRoles));
                },

                savePlayersToLocalStorage() {
                    localStorage.setItem('players', JSON.stringify(this.players));
                },

                allRolesAreAssigned() {
                    return this.players.every(player => player.role);
                },

                exit() {
                    // Return to the gameplay page.
                    window.location.href = 'gameplay.html';
                },

                uploadGameData(requestType = "update") {
                    // Upload game data by saving to a remote JSON file

                    const gameName = localStorage.getItem('gameName');

                    const isSecondHalf = localStorage.getItem('isSecondHalf') || false;
                    const isGameOver = localStorage.getItem('isGameOver') || false;
                    const isGameStarted = localStorage.getItem('isGameStarted') || false;
                    const gameStartTime = localStorage.getItem('gameStartTime') || "";
                    const isScanStarted = localStorage.getItem('isScanStarted') || false;

                    const gameState = {
                        players: this.players,
                        extraRoles: this.extraRoles,
                        isScanStarted: isScanStarted,
                        isGameStarted: isGameStarted,
                        gameName: gameName,
                        gameStartTime: gameStartTime,
                        isNetworkGame: true,
                        isSecondHalf: isSecondHalf,
                        isGameOver: isGameOver
                    };

                    console.log(gameState);

                    let headers = {
                        'Content-Type': 'application/json',
                        'X-Master-Key': '$2a$10$xBWoQfSrf2axQlkjjmFea.T0zIXfJ9pznRuSTArk1mGZe6/Fg7cOW'
                    };
                    let url = '';

                    // Modify the URL and headers based on the request type
                    if (requestType === "create") {
                        url = 'https://api.jsonbin.io/v3/b';
                        headers['X-Bin-Name'] = gameName;
                        headers['X-Collection-Id'] = '678ff8e4acd3cb34a8d0b110';
                    }
                    else {
                        const gameId = localStorage.getItem('gameId');
                        url = `https://api.jsonbin.io/v3/b/${gameId}`;
                    }

                    fetch(url, {
                        method: requestType === "create" ? 'POST' : 'PUT',
                        headers: headers,
                        body: JSON.stringify(gameState)
                    })
                        .then(response => response.json())
                        .then(data => {
                            console.log(data);
                            if (requestType === "create") {
                                // Retrieve the game ID and save it to local storage
                                localStorage.setItem('gameId', data.metadata.id);
                            }
                        });
                },

                startTheGame() {
                    // Prepare the game and display a 3-second countdown

                    localStorage.removeItem('isScanStarted');
                    localStorage.setItem('isGameStarted', true);
                    localStorage.setItem('gameStartTime', new Date().getTime());
                    localStorage.setItem('isSecondHalf', false);

                    // If this is a network game, upload the game data to indicate the game has started
                    if (localStorage.getItem('isNetworkGame') === "true") {
                        this.uploadGameData("update");
                    }

                    let count = 3;
                    const countdown = setInterval(() => {
                        if (count > 0) {
                            this.gameInfo = `Game starting in...${count}`;
                            count--;
                        } else {
                            clearInterval(countdown);
                            window.location.href = 'gameplay.html';
                        }
                    }, 1000);

                },

                isHoundskeeperInGame() {
                    // Return whether the Houndskeeper is in the game

                    // Get all the players, plus extra roles
                    const allRoles = this.players.map(player => player.role).concat(this.extraRoles);

                    if (allRoles.includes('houndskeeper'))
                        return true;
                    else
                        return false;
                },

                init() {

                    const isGameOver = localStorage.getItem('isGameOver') === 'true';
                    const isGameStarted = localStorage.getItem('isGameStarted') === 'true';
                    const isClient = localStorage.getItem('isClient') === 'true';
                    const isScanStarted = localStorage.getItem('isScanStarted') === 'true';
                    const gameId = localStorage.getItem('gameId');

                    // If the user is a client (and not the game host)...
                    if (isClient) {
                        // If the client user attempts a scan and the game has not started, check the network game status                
                        if (!isGameStarted) {
                            // When Download is complete it will call the initializeGameVariables function
                            this.downloadGameData();
                        }
                        else {
                            // Call the initializeGameVariables function directly
                            this.initializeGameVariables();
                        }
                    }
                    else {
                        // Host use simply initializes the game variables without checking the network game status
                        this.initializeGameVariables();
                    }

                    // If the role scan has started, but the game hasn't, assign roles
                    if (isScanStarted && !isGameStarted) {
                        console.log('Role scan detected: assigning roles');
                        if (this.extraRoles.length < 3) {
                            this.assignRoles();
                        }

                        // If all the necessary cards have now been scanned, start the game, otherwise scan the next card
                        if (this.allRolesAreAssigned() && this.extraRoles.length === 3)
                            if (localStorage.getItem('isNetworkGame') === "true") {
                                if (gameId)
                                    this.uploadGameData("update");
                                else
                                    this.uploadGameData("create");
                                this.showStartGameButton = true;
                                this.gameInfo = 'All roles have been assigned.';
                            }
                            else {
                                this.startTheGame();
                            }
                        else {
                            window.location.href = 'next_player_to_scan.html';
                        }
                    }

                    // Check if a player beside this one is sniffing and show the sniff screen if so
                    sniffingPlayer = this.players.find(player => player.isSniffing);
                    if (sniffingPlayer) {
                        isAdjacent = sniffingPlayer == this.getAdjacentPlayer("left") || sniffingPlayer == this.getAdjacentPlayer("right");
                        if (isAdjacent) {
                            this.showSniffScreen = true;
                            this.receiveSniff(sniffingPlayer);
                        }
                    }
                },

                assignRoles() {
                    // Assign roles to the players and extra roles array

                    // If all player roles have been assigned, scan the extra roles, otherwise keep scanning the players.
                    if (this.allRolesAreAssigned()) {
                        this.assignExtraRole();
                    }
                    else {
                        this.assignRole(this.getRole());
                    }
                },

                downloadGameData() {
                    // Download the game data from the remote JSON file

                    return new Promise((resolve, reject) => {

                        const gameId = localStorage.getItem('gameId');
                        fetch(`https://api.jsonbin.io/v3/b/${gameId}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Master-Key': '$2a$10$xBWoQfSrf2axQlkjjmFea.T0zIXfJ9pznRuSTArk1mGZe6/Fg7cOW'
                            }
                        })
                            .then(response => response.json())
                            .then(data => {
                                console.log(data);
                                localStorage.setItem('players', JSON.stringify(data.record.players));
                                localStorage.setItem('extraRoles', JSON.stringify(data.record.extraRoles));
                                localStorage.setItem('isGameStarted', data.record.isGameStarted);
                                localStorage.setItem('isSecondHalf', data.record.isSecondHalf);
                                localStorage.setItem('isGameOver', data.record.isGameOver);
                                localStorage.setItem('gameStartTime', data.record.gameStartTime);

                                // Check again if the game has started after downloading the game data
                                if (data.record.isGameStarted !== "true") {
                                    // The still game hasn't started, so redirect the user to the gameplay page
                                    window.location.href = 'gameplay.html';
                                    return;
                                }
                                // Initialize the game variables now that data is downloaded
                                this.initializeGameVariables();

                                // Resolve the promise
                                resolve();
                            });
                    });
                },

                initializeGameVariables() {
                    // Set up the Alpine variables used on this page for game controls and rules.

                    console.log('Initializing game variables');

                    const isGameStarted = localStorage.getItem('isGameStarted') === 'true';

                    // If the game has started, display the special ability screen
                    if (isGameStarted)
                        this.specialAbilityVisible = true;

                    // Load the necessary variables from local storage
                    this.loadPlayersFromLocalStorage();
                    this.loadExtraRolesFromLocalStorage();
                    this.getRole();

                    // Temporarily reset the usedAbility flag for all players TESTING!!!!!!!!!!!!!!!!!!!!!!!
                    // this.players = this.players.map(player => ({ ...player, usedAbility: false }));
                    // Temporarily reset the usedAbility flag for all players TESTING!!!!!!!!!!!!!!!!!!!!!!!

                    // Determine if the Houndskeeper is in the game and set the controls accordingly
                    this.isHoundskeeper = this.isHoundskeeperInGame();
                },

                activateRole() {
                    // Depending on the role, the player can activate a special ability.
                    // Some roles require additional controls to perform their ability.
                    const role = this.getRole();
                    const currentPlayer = this.getCurrentPlayer();
                    console.log(currentPlayer);
                    const specialAbilityDiv = document.getElementById('specialAbility');
                    const abilityMessage = document.getElementById('abilityMessage');

                    // Hide the main special ability button
                    this.showMainAbilityButton = false;

                    if (currentPlayer.usedAbility) {
                        abilityMessage.textContent = 'You have already used your ability';
                        return;
                    }

                    if (role === 'tracker') {
                        // If the role is tracker, display the tracking buttons and hide the main special ability button
                        this.showTrackerButtons = true;
                    } else if (role === 'watcher') {
                        // If the role is watcher, display the watcher controls
                        this.showWatcherControls = true;
                        this.playersToView = this.players.filter(player => player.role && player.role !== 'watcher');
                    } else if (role === 'villager') {
                        // If the role is villager, display the villager controls for voting
                        this.showVillagerControls = true;
                        this.playersToVote = this.players.filter(player => player.role && player.id !== currentPlayer.id);
                    } else if (role === 'werewolf' && this.isHoundskeeper) {
                        // If the role is werewolf or houndskeeper, activate the sniff ability
                        this.sniffAbility();
                    } else if (role === 'houndskeeper') {
                        this.sniffAbility();
                    } else if (role === 'saint') {
                        this.saintAbility();
                    } else if (role === 'astrologer') {
                        this.astrologerAbility();
                    } else if (role === 'turncloak') {
                        this.turncloakAbility();
                    } else if (role === 'drifter') {
                        this.drifterAbility();
                    } else if (role === 'gossip') {
                        // For the gossip, the ability is performed once, and the results are saved for later
                        // So if the the gossip clues have already been created, just display them and don't execute the ability again
                        // Display the first gossip message during the first half of the game and both during the second half                       

                        const firstGossip = localStorage.getItem('firstGossip') && localStorage.getItem('firstGossip') !== "null";
                        const secondGossip = localStorage.getItem('secondGossip') && localStorage.getItem('secondGossip') !== "null";
                        let isSecondHalf = localStorage.getItem('isSecondHalf') === "true";

                        if (firstGossip && secondGossip) {
                            this.gossip1 = localStorage.getItem('firstGossip');
                            // strip the quotes from the string

                            if (isSecondHalf) {
                                console.log("second half");
                                this.gossip2 = localStorage.getItem('secondGossip');
                            }
                        } else {
                            console.log("gossip ability activated");
                            this.gossipAbility();
                        }
                    } else {
                        bluffingMessages = [
                            "Keep a straight face",
                            "How will you get out of this one?",
                            "You're bluffing, right?",
                            "In for a penny, in for a pound",
                            "You're in deep now",
                            "Do you think they're buying it?",
                            "Do you sell used cars?",
                            "The elder gods frown upon your deceit",
                            "Is this your plan?",
                            "You're not fooling anyone",
                            "Do you have a poker face?",
                            "Do you think you're clever?",
                            "Do you kiss your mother with those lying lips?",
                            "It's not a lie if you believe it",
                            "The bigger the lie, the more they'll believe it",
                            "You're a regular Pinocchio",
                            "All is fair in love and werewolves",
                        ];
                        abilityMessage.textContent = bluffingMessages[Math.floor(Math.random() * bluffingMessages.length)];

                        // Activate special effects
                        this.specialEffects();
                    }
                },
                villagerAbility() {
                    // Villagers can appoint a ringleader, who casts two votes at the end

                    let selectedPlayerName = this.players.find(player => player.id === this.selectedPlayer).name;

                    // Download the network data
                    if (localStorage.getItem('isNetworkGame') === "true") {
                        this.downloadGameData().then(() => {
                            this.getCurrentPlayer().usedAbility = true;
                            // Add a vote to the tally of whoever the player chose
                            let selectedPlayer = this.players.find(player => player.id === this.selectedPlayer);
                            selectedPlayer.mayorVotes++;

                            console.log("The selected player is:");
                            console.log(selectedPlayer.name);

                            console.log("the players are now:");
                            console.log(this.players);

                            this.savePlayersToLocalStorage();

                            // Upload the network data
                            this.uploadGameData("update");
                        });
                    }
                    else {
                        // TODO: eliminate repitition here
                        // Mark the player as having used their ability
                        this.getCurrentPlayer().usedAbility = true;
                        this.savePlayersToLocalStorage();

                        // Add a vote to the tally of whoever the player chose
                        let selectedPlayer = this.players.find(player => player.id === this.selectedPlayer);
                        selectedPlayer.mayorVotes++;
                        this.savePlayersToLocalStorage();
                    }

                    // Remove the dropdown after the ability is used
                    this.showVillagerControls = false;

                    abilityMessage.textContent = `You have voted ${selectedPlayerName} for ringleader`;

                    // Activate special effects
                    this.specialEffects();

                },
                saintAbility() {
                    // The saint learns the identity of a werewolf
                    const werewolfPlayers = this.players.filter(player => player.role === 'werewolf');
                    const randomWerewolf = werewolfPlayers[Math.floor(Math.random() * werewolfPlayers.length)];
                    abilityMessage.textContent = randomWerewolf ? `${randomWerewolf.name} is a werewolf` : 'No werewolf found';

                    this.specialEffects();

                    // Mark the player as having used their ability
                    this.getCurrentPlayer().usedAbility = true;
                    this.savePlayersToLocalStorage();
                },

                astrologerAbility() {
                    // The astrologer learns if any special roles are present

                    // Get all the special roles in this game except werewolf, villager, and astrologer
                    const possibleRoles = this.players
                        .filter(player => player.role && player.role !== 'werewolf' && player.role !== 'villager' && player.role !== 'astrologer')
                        .map(player => player.role);

                    // Now, pick a random role from the possible roles
                    const randomRole = possibleRoles[Math.floor(Math.random() * possibleRoles.length)];
                    abilityMessage.textContent = randomRole ? `The ${randomRole} is present` : 'No special roles found';

                    this.specialEffects();

                    // Mark the player as having used their ability
                    this.getCurrentPlayer().usedAbility = true;
                    this.savePlayersToLocalStorage();
                },

                drifterAbility() {
                    // The drifter discovers 2 roles that are not in play

                    // Pick two random roles from the 3 extras
                    const drifterResult = this.extraRoles.sort(() => 0.5 - Math.random()).slice(0, 2);

                    let prefix = "";
                    let clue = "";

                    drifterResultRolesAreSame = drifterResult[0] == drifterResult[1];

                    // If the results contain the same role, change up the wording
                    if (drifterResultRolesAreSame) {
                        if (drifterResult[0] == "werewolf")
                            clue = "Two less werewolves";
                        else if (drifterResult[0] == "villager")
                            clue = "Two less villagers";
                    }
                    else {
                        for (drifterResultRole of drifterResult) {
                            if (drifterResultRole == "werewolf" || drifterResultRole == "villager")
                                prefix = "One less ";
                            else
                                prefix = "No ";

                            clue += prefix + drifterResultRole + ". ";
                        }
                    }

                    abilityMessage.textContent = clue;

                    this.specialEffects();

                    // Mark the player as having used their ability
                    this.getCurrentPlayer().usedAbility = true;
                    this.savePlayersToLocalStorage();
                },

                turncloakAbility() {
                    // The turncloak learns the identity of the werewolves
                    const werewolfPlayers = this.players.filter(player => player.role === 'werewolf');
                    const werewolfNames = werewolfPlayers.map(player => player.name).join(' and ');

                    if (werewolfPlayers.length === 0) {
                        abilityMessage.textContent = 'No werewolves';
                    } else if (werewolfPlayers.length === 1) {
                        abilityMessage.textContent = `Your werewolf is ${werewolfNames}`;
                    }
                    else {
                        abilityMessage.textContent = `Your werewolves are ${werewolfNames}`;
                    }

                    this.specialEffects();
                },

                gossipAbility() {
                    // The gossip learns something about 2 random players. One is true, the other is true or false.

                    console.log("Getting the gossip ability and players");
                    console.log(this.players);

                    // Get all players except the gossip, and shuffle them
                    let players = this.players;
                    players = players.filter(player => player.role !== 'gossip');

                    let randomPlayers = players.sort(() => 0.5 - Math.random());
                    console.log("players are:");
                    console.log(players);
                    console.log("random players are:");
                    console.log(randomPlayers);

                    // Pop off two random players
                    trueRole = randomPlayers.pop();
                    maybeRole = randomPlayers.pop();

                    // Prepare the true gossip by picking out the first random player.
                    trueGossip = `${trueRole.name} may be ${useAorAn(trueRole.role)} ${trueRole.role}`;

                    // Prepare the potentially false gossip -- 50% chance
                    const isTrueGossip = Math.random() < 0.5;

                    if (isTrueGossip) {
                        maybeGossip = `${maybeRole.name} may be ${useAorAn(maybeRole.role)} ${maybeRole.role}`;
                    } else {
                        const randomRole = randomPlayers.pop().role;
                        maybeGossip = `${maybeRole.name} may be ${useAorAn(randomRole)} ${randomRole}`;
                    }

                    // Now that we have our 2 gossips, choose a random order to display them
                    const gossips = [trueGossip, maybeGossip];
                    const randomGossipOrder = gossips.sort(() => 0.5 - Math.random());

                    this.gossip1 = randomGossipOrder[0];

                    // Only display the second gossip if it's halfway through the game, otherwise save it for later
                    if (localStorage.getItem('isSecondHalf') && localStorage.getItem('isSecondHalf') === "true") {
                        this.gossip2 = randomGossipOrder[1];
                    }

                    // Save both gossips for later since the gossip can use their ability more than once.
                    localStorage.setItem('firstGossip', randomGossipOrder[0]);
                    localStorage.setItem('secondGossip', randomGossipOrder[1]);

                    this.specialEffects();
                },

                watcherAbility() {
                    // The watcher can view the role of another player. They'll get a true and false clue.
                    const selectedPlayer = this.players.find(player => player.name === this.selectedPlayer);
                    const abilityMessage = document.getElementById('abilityMessage');

                    // Get all roles except the watcher and the selected player
                    let playerRoles = this.players
                        .filter(player => player.role && player.role !== 'watcher' && player.role !== selectedPlayer.role)
                        .map(player => player.role);
                    let allRoles = playerRoles.concat(this.extraRoles);

                    // Shuffle the roles and grab one to use as the false role clue
                    allRoles = allRoles.sort(() => 0.5 - Math.random());
                    const falseRole = allRoles.pop();

                    // Shuffle the false role with the player's real role
                    const roleClues = [selectedPlayer.role, falseRole].sort(() => 0.5 - Math.random());

                    if (selectedPlayer) {
                        abilityMessage.textContent =
                            `${selectedPlayer.name} is either ${useAorAn(roleClues[0])} ${roleClues[0]} 
                                or ${useAorAn(roleClues[1])} ${roleClues[1]}`;
                    } else {
                        abilityMessage.textContent = 'Player not found';
                    }
                    // Remove the dropdown after the ability is used
                    this.showWatcherControls = false;

                    // Activate special effects
                    this.specialEffects();

                    // Mark the player as having used their ability
                    this.getCurrentPlayer().usedAbility = true;
                    this.savePlayersToLocalStorage();
                },

                trackerAbility(trackDirection) {
                    // The tracker chooses which half of the players at the table track; this determines if a wolf is among them.

                    // Get the total player count
                    const totalPlayers = this.players.length;
                    // Get the position of the current player
                    const currentPlayerIndex = this.players.findIndex(player => player.role === 'tracker');
                    const numberToBeTracked = Math.floor(totalPlayers / 2);
                    let playersToTrack = [];

                    if (trackDirection == 'left') {
                        // for loop for the number to be tracked
                        for (let i = 1; i <= numberToBeTracked; i++) {
                            let playerToTrackIndex = currentPlayerIndex + i;
                            if (playerToTrackIndex > totalPlayers - 1) {
                                playerToTrackIndex = playerToTrackIndex - totalPlayers;
                            }
                            playersToTrack.push(this.players[playerToTrackIndex]);
                        }
                    }
                    else if (trackDirection == 'right') {
                        // for loop for the number to be tracked
                        for (let i = 1; i <= numberToBeTracked; i++) {
                            let playerToTrackIndex = currentPlayerIndex - i;
                            if (playerToTrackIndex < 0) {
                                playerToTrackIndex = totalPlayers + playerToTrackIndex;
                            }
                            playersToTrack.push(this.players[playerToTrackIndex]);
                        }
                    }
                    if (playersToTrack.length === 2) {
                        trackedPlayerNamesString = playersToTrack.map(player => player.name).join(', ');
                    }
                    else {
                        trackedPlayerNamesString = playersToTrack.map(player => player.name).join(' and ');
                    }
                    const werewolfWasFound = playersToTrack.find(player => player.role === 'werewolf');
                    abilityMessage.textContent = werewolfWasFound ? `A werewolf hides amongst ${trackedPlayerNamesString}` : `No werewolves amongst ${trackedPlayerNamesString}`;

                    // Activate special effects
                    this.specialEffects();

                    // Mark the player as having used their ability
                    this.getCurrentPlayer().usedAbility = true;
                    this.savePlayersToLocalStorage();
                },

                getAdjacentPlayer(direction) {
                    // Get the adjacent player to the current player, given the direction (left or right)

                    const currentPlayer = this.getCurrentPlayer();
                    const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);
                    let nextPlayerIndex = 0;

                    if (direction === "left") {
                        nextPlayerIndex = currentPlayerIndex + 1;
                        if (nextPlayerIndex > this.players.length - 1) {
                            nextPlayerIndex = 0;
                        }
                    } else if (direction === "right") {
                        nextPlayerIndex = currentPlayerIndex - 1;
                        if (nextPlayerIndex < 0) {
                            nextPlayerIndex = this.players.length - 1;
                        }
                    }
                    return this.players[nextPlayerIndex];
                },

                sniffAbility() {
                    // A werewolf or houndskeeper can sniff out the role of either player next to them
                    let currentPlayer = this.getCurrentPlayer();
                    const abilityMessage = document.getElementById('abilityMessage');

                    // Get the index of the current player
                    const currentPlayerIndex = this.players.findIndex(player => player.id === currentPlayer.id);

                    if (currentPlayer.sniffResults.length > 0) {
                        abilityMessage.textContent = currentPlayer.sniffResults.join(' and ');
                    } else {
                        abilityMessage.textContent += "You have not successfully sniffed anyone yet";
                    }

                    // Reset the sniffing flag for the current player
                    currentPlayer.isSniffing = false;
                    this.savePlayersToLocalStorage();

                    this.specialEffects();
                },

                specialEffects() {
                    // Play the sound effect            
                    this.audio.play();

                    // Animation for main controls
                    const useAbilityButton = document.getElementById('useAbilityButton');
                    useAbilityButton.classList.add('fade-out');
                    useAbilityButton.addEventListener('transitionend', () => {
                        useAbilityButton.style.display = 'none';
                    }, { once: true });

                    // Animation for tracker controls
                    if (this.role === "tracker") {
                        // Hide the track buttons after the ability is used
                        document.getElementById('trackLeftButton').classList.add('slide-right-fade-out');
                        document.getElementById('trackRightButton').classList.add('slide-left-fade-out');
                    }

                    // Animation for the background effect
                    const abilityEffect = document.getElementById('ability-effect');
                    abilityEffect.classList.add('growing');

                    // Animation for the special ability message
                    const abilityMessage = document.getElementById('abilityMessage');
                    abilityMessage.style.display = 'block';
                }
            }
        }   
    </script>
</body>

</html>